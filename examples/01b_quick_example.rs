#![feature(attr_literals)]
#![feature(custom_derive)]
#![feature(proc_macro)]

extern crate clap;
extern crate stomp;
#[macro_use]
extern crate stomp_macros;

use stomp::RunApp;

// Create an application with 5 possible arguments (2 auto generated) and 2 subcommands (1 auto generated)
//    - A config file
//        + Uses "-c filename" or "--config filename"
//    - An output file
//        + A positional argument (i.e. "$ myapp output_filename")
//    - A debug flag
//        + Uses "-d" or "--debug"
//        + Allows multiple occurrences of such as "-dd" (for vary levels of debugging, as an example)
//    - A help flag (automatically generated by clap)
//        + Uses "-h" or "--help" (Only autogenerated if you do NOT specify your own "-h" or "--help")
//    - A version flag (automatically generated by clap)
//        + Uses "-V" or "--version" (Only autogenerated if you do NOT specify your own "-V" or "--version")
//    - A subcommand "test" (subcommands behave like their own apps, with their own arguments
//        + Used by "$ myapp test" with the following arguments
//            > A list flag
//                = Uses "-l" (usage is "$ myapp test -l"
//            > A help flag (automatically generated by clap
//                = Uses "-h" or "--help" (full usage "$ myapp test -h" or "$ myapp test --help")
//            > A version flag (automatically generated by clap
//                = Uses "-V" or "--version" (full usage "$ myapp test -V" or "$ myapp test --version")
//    - A subcommand "help" (automatically generated by clap because we specified a subcommand of our own)
//        + Used by "$ myapp help" (same functionality as "-h" or "--help")

/// Does awesome things.
#[derive(StompCommand)]
#[stomp(name = "MyApp", version = "1.0")]
#[stomp(author = "Nemo157 <stomp@nemo157.com>")]
pub struct MyApp {
    /// Sets a custom config file
    #[stomp(short = 'c', value_name = "FILE")]
    config: Option<String>,

    /// Sets an optional output file
    #[stomp(index = 1)]
    output: Option<String>,

    /// Turn debugging information on
    #[stomp(counter, short = 'd', long = "debug")]
    debug_level: usize,

    #[stomp(subcommand)]
    subcommand: Option<Commands>,
}

#[derive(StompCommands)]
#[stomp(context = "()")]
pub enum Commands {
    Test(Test),
}

/// does testing things
#[derive(StompCommand)]
pub struct Test {
    /// lists test values
    #[stomp(short = 'l')]
    list: bool,
}

impl stomp::Executor for MyApp {
    type Context = ();
    fn run(self, _context: Self::Context) {
        // You can check the value provided by positional arguments, or option arguments
        if let Some(o) = self.output {
            println!("Value for output: {}", o);
        }

        if let Some(c) = self.config {
            println!("Value for config: {}", c);
        }

        // You can see how many times a particular flag or argument occurred
        // Note, only flags can have multiple occurrences
        match self.debug_level {
            0 => println!("Debug mode is off"),
            1 => println!("Debug mode is kind of on"),
            2 => println!("Debug mode is on"),
            3 | _ => println!("Don't be crazy"),
        }

        // You can check for the existence of subcommands, and if found use their
        // matches just as you would the top level app
        if let Some(subcommand) = self.subcommand {
            subcommand.run(());
        }

        // Continued program logic goes here...
    }
}

impl stomp::Executor for Test {
    type Context = ();
    fn run(self, _context: Self::Context) {
        if self.list {
            // "$ myapp test -l" was run
            println!("Printing testing lists...");
        } else {
            // "$ myapp test" was run
            println!("Not printing testing lists...");
        }

        // Continued program logic goes here...
    }
}

fn main() {
    MyApp::run_app();
}
